import logging
import math
import time
from datetime import datetime

import numpy as np
import pandas as pd
import yfinance as yf

logger = logging.getLogger(__name__)


def _retry(operation, module_name: str, retries: int = 3, base_delay: float = 1.0):
    last_error = None
    for attempt in range(retries):
        try:
            return operation()
        except Exception as e:
            last_error = e
            logger.error(f"{module_name} error: {e}")
            time.sleep(base_delay * (2 ** attempt))
    raise RuntimeError(f"{module_name} failed after retries") from last_error


def norm_cdf(x):
    return 0.5 * (1 + math.erf(x / math.sqrt(2)))


def calculate_greeks(spot: float, strike: float, t: float, rate: float, iv: float, kind: str):
    if spot <= 0 or strike <= 0 or t <= 0 or iv <= 0:
        return {"Delta": 0.0, "Gamma": 0.0, "Theta": 0.0, "Vega": 0.0}
    d1 = (math.log(spot / strike) + (rate + 0.5 * iv * iv) * t) / (iv * math.sqrt(t))
    d2 = d1 - iv * math.sqrt(t)
    pdf = math.exp(-0.5 * d1 * d1) / math.sqrt(2 * math.pi)
    if kind == "CE":
        delta = norm_cdf(d1)
        theta = (-(spot * pdf * iv) / (2 * math.sqrt(t)) - rate * strike * math.exp(-rate * t) * norm_cdf(d2)) / 365
    else:
        delta = norm_cdf(d1) - 1
        theta = (-(spot * pdf * iv) / (2 * math.sqrt(t)) + rate * strike * math.exp(-rate * t) * norm_cdf(-d2)) / 365
    gamma = pdf / (spot * iv * math.sqrt(t))
    vega = (spot * math.sqrt(t) * pdf) / 100
    return {"Delta": round(delta, 3), "Gamma": round(gamma, 4), "Theta": round(theta, 3), "Vega": round(vega, 3)}


def get_available_expiries(symbol: str) -> list[str]:
    try:
        exps = _retry(lambda: list(yf.Ticker(symbol).options), "options_expiries")
    except Exception:
        return []
    return exps[:3]


def fetch_option_chain(symbol: str, expiry: str):
    def _load_chain():
        return yf.Ticker(symbol).option_chain(expiry)

    chain = _retry(_load_chain, "options_chain")
    spot_data = _retry(lambda: yf.download(symbol, period="2d", progress=False), "options_spot")
    spot = float(spot_data["Close"].dropna().iloc[-1]) if not spot_data.empty else 0.0
    t = max((datetime.strptime(expiry, "%Y-%m-%d") - datetime.now()).days / 365.0, 1 / 365)

    call_df = chain.calls.copy()
    put_df = chain.puts.copy()
    call_df["Type"] = "CE"
    put_df["Type"] = "PE"
    combined = pd.concat([call_df, put_df], ignore_index=True)
    combined = combined.rename(columns={"strike": "Strike", "openInterest": "OI", "impliedVolatility": "IV", "lastPrice": "Premium"})
    combined["IV"] = pd.to_numeric(combined["IV"], errors="coerce").fillna(0.2).clip(0.01, 3)
    greeks = combined.apply(lambda r: calculate_greeks(spot, float(r["Strike"]), t, 0.06, float(r["IV"]), r["Type"]), axis=1).apply(pd.Series)
    combined = pd.concat([combined, greeks], axis=1)
    combined["OI"] = pd.to_numeric(combined["OI"], errors="coerce").fillna(0)
    combined["Premium"] = pd.to_numeric(combined["Premium"], errors="coerce").fillna(0)
    return combined[["Strike", "Type", "IV", "Delta", "Gamma", "Theta", "Vega", "OI", "Premium", "contractSymbol"]], spot, t


def scan_strategies(chain_df: pd.DataFrame, oi_threshold: int = 10000, iv_threshold: float = 0.2):
    if chain_df.empty:
        return pd.DataFrame()
    eligible = chain_df[(chain_df["OI"] >= oi_threshold) & (chain_df["IV"] >= iv_threshold)]
    ce = eligible[eligible["Type"] == "CE"]
    pe = eligible[eligible["Type"] == "PE"]
    if ce.empty or pe.empty:
        return pd.DataFrame()

    atm_strike = chain_df.iloc[(chain_df["Strike"] - chain_df["Strike"].median()).abs().argsort()].iloc[0]["Strike"]
    ce_atm = ce.iloc[(ce["Strike"] - atm_strike).abs().argsort()].head(1)
    pe_atm = pe.iloc[(pe["Strike"] - atm_strike).abs().argsort()].head(1)
    if ce_atm.empty or pe_atm.empty:
        return pd.DataFrame()

    straddle_premium = float(ce_atm["Premium"].iloc[0] + pe_atm["Premium"].iloc[0])
    strangle_ce = ce[ce["Strike"] > atm_strike].sort_values("Strike").head(1)
    strangle_pe = pe[pe["Strike"] < atm_strike].sort_values("Strike", ascending=False).head(1)
    strangle_premium = float(strangle_ce["Premium"].sum() + strangle_pe["Premium"].sum())

    return pd.DataFrame([
        {"Strategy": "Short Straddle", "Strike": atm_strike, "Premium": straddle_premium, "IV": float((ce_atm["IV"].iloc[0] + pe_atm["IV"].iloc[0]) / 2)},
        {"Strategy": "Short Strangle", "Strike": f"{strangle_pe['Strike'].iloc[0]} / {strangle_ce['Strike'].iloc[0]}", "Premium": strangle_premium, "IV": float((strangle_ce["IV"].iloc[0] + strangle_pe["IV"].iloc[0]) / 2)},
    ])


def payoff_curve(strikes: np.ndarray, strategy: str, premium: float, atm: float):
    if strategy == "Short Straddle":
        return premium - np.abs(strikes - atm)
    width = max(1, int(atm * 0.01))
    return premium - np.maximum(0, strikes - (atm + width)) - np.maximum(0, (atm - width) - strikes)
